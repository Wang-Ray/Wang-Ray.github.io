---


layout: post


title: "读书笔记之《分布式服务架构：原理、设计与实战》"


date: 2019-04-09 09:03:13 +0800


categories: 综合


tags: comprehensive UML distributed architecture


---





第1章 分布式微服务架构设计原理	1





 





1.1 从传统单体架构到服务化架构	2





 





1.1.1 JEE架构	2





 





1.1.2 SSH架构	5





 





1.1.3 服务化架构	8





 





1.2 从服务化到微服务	11





 





1.2.1 微服务架构的产生	12





 





1.2.2 微服务架构与传统单体架构的对比	13





 





1.2.3 微服务架构与SOA服务化的对比	15





 





1.3 微服务架构的核心要点和实现原理	16





 





1.3.1 微服务架构中职能团队的划分	16





 





1.3.2 微服务的去中心化治理	18





 





1.3.3 微服务的交互模式	18





 





1.3.4 微服务的分解和组合模式	22





 





1.3.5 微服务的容错模式	35





 





1.3.6 微服务的粒度	41





 





1.4 Java平台微服务架构的项目组织形式	42





 





1.4.1 微服务项目的依赖关系	42





 





1.4.2 微服务项目的层级结构	43





 





1.4.3 微服务项目的持续发布	45





 





1.5 服务化管理和治理框架的技术选型	45





 





1.5.1 RPC	46





 





1.5.2 服务化	47





 





1.5.3 微服务	49





 





1.6 本章小结	52





 





第2章 彻底解决分布式系统一致性的问题	54





2.1 什么是一致性	55





 





2.2 一致性问题	56





 





2.3 解决一致性问题的模式和思路	57





 





2.3.1 酸碱平衡理论	58





 





2.3.2 分布式一致性协议	61





 





2.3.3 保证最终一致性的模式	67





 





2.4 超时处理模式	75





 





2.4.1 微服务的交互模式	76





 





2.4.2 同步与异步的抉择	77





 





2.4.3 交互模式下超时问题的解决方案	78





 





2.4.4 超时补偿的原则	85





 





2.5 迁移开关的设计	87





 





2.6 本章小结	88





 





第3章 服务化系统容量评估和性能保障	89





3.1 架构设计与非功能质量	90





 





3.2 全面的非功能质量需求	91





 





3.2.1 非功能质量需求的概述	91





 





3.2.2 非功能质量需求的具体指标	92





 





3.3 典型的技术评审提纲	97





 





3.3.1 现状	97





 





3.3.2 需求	98





 





3.3.3 方案描述	98





 





3.3.4 方案对比	99





 





3.3.5 风险评估	100





 





3.3.6 工作量评估	100





 





3.4 性能和容量评估经典案例	100





 





3.4.1 背景	100





 





3.4.2 目标数据量级	101





 





3.4.3 量级评估标准	101





 





3.4.4 方案	102





 





3.4.5 小结	107





 





3.5 性能评估参考标准	108





 





3.5.1 常用的应用层性能指标参考标准	108





 





3.5.2 常用的系统层性能指标参考标准	109





 





3.6 性能测试方案的设计和最佳实践	112





 





3.6.1 明确压测目标	112





 





3.6.2 压测场景设计和压测方案制定	114





 





3.6.3 准备压测环境	121





 





3.6.4 压测的执行	122





 





3.6.5 问题修复和系统优化	123





 





3.7 有用的压测工具	123





 





3.7.1 ab	123





 





3.7.2 jmeter	125





 





3.7.3 mysqlslap	125





 





3.7.4 sysbench	129





 





3.7.5 dd	134





 





3.7.6 LoadRunner	135





 





3.7.7 hprof	136





 





3.8 本章小结	138





 





第4章 大数据日志系统的构建	140





4.1 开源日志框架的原理分析与应用实践	142





 





4.1.1 JDK Logger	142





 





4.1.2 Apache Commons Logging	143





 





4.1.3 Apache Log4j	147





 





4.1.4 Slf4j	156





 





4.1.5 Logback	160





 





4.1.6 Apache Log4j 2	164





 





4.2 日志系统的优化和最佳实践	168





 





4.2.1 开发人员的日志意识	168





 





4.2.2 日志级别的设置	168





 





4.2.3 日志的数量和大小	169





 





4.2.4 切割方式	170





 





4.2.5 日志格式的配置	170





 





4.2.6 一行日志导致的线上事故	177





 





4.3 大数据日志系统的原理与设计	178





 





4.3.1 通用架构和设计	179





 





4.3.2 日志采集器	180





 





4.3.3 日志缓冲队列	186





 





4.3.4 日志解析器	187





 





4.3.5 日志存储和搜索	187





 





4.3.6 日志展示系统	188





 





4.3.7 监控和报警	188





 





4.3.8 日志系统的容量和性能评估	188





 





4.4 ELK系统的构建与使用	190





 





4.4.1 Elasticsearch	191





 





4.4.2 Logstash	193





 





4.4.3 Kibana	196





 





4.5 本章小结	198





 





第5章 基于调用链的服务治理系统的设计与实现	199





5.1 APM系统简介	200





 





5.1.1 优秀的开源APM系统	200





 





5.1.2 国内商业APM产品的介绍	202





 





5.2 调用链跟踪的原理	203





 





5.2.1 分布式系统的远程调用过程	204





 





5.2.2 TraceID	207





 





5.2.3 SpanID	208





 





5.2.4 业务链	210





 





5.3 调用链跟踪系统的设计与实现	211





 





5.3.1 整体架构	211





 





5.3.2 TraceID和SpanID在服务间的传递	213





 





5.3.3 采集器的设计与实现	217





 





5.3.4 处理器的设计与实现	222





 





5.3.5 调用链系统的展示	225





 





5.4 本章小结	226





 





第6章 Java服务的线上应急和技术攻关	227





6.1 海恩法则和墨菲定律	227





 





6.2 线上应急的目标、原则和方法	229





 





6.2.1 应急目标	229





 





6.2.2 应急原则	229





 





6.2.3 线上应急的方法和流程	230





 





6.3 技术攻关的方法论	233





 





6.4 环境搭建和示例服务启动	236





 





6.5 高效的服务化治理脚本	240





 





6.5.1 show-busiest-java-threads	240





 





6.5.2 find-in-jar	243





 





6.5.3 grep-in-jar	244





 





6.5.4 jar-conflict-detect	245





 





6.5.5 http-spy	247





 





6.5.6 show-mysql-qps	248





 





6.5.7 小结	249





 





6.6 JVM提供的监控命令	249





 





6.6.1 jad	249





 





6.6.2 btrace	250





 





6.6.3 jmap	252





 





6.6.4 jstat	255





 





6.6.5 jstack	256





 





6.6.6 jinfo	258





 





6.6.7 其他命令	258





 





6.6.8 小结	259





 





6.7 重要的Linux基础命令	260





 





6.7.1 必不可少的基础命令和工具	260





 





6.7.2 查看活动进程的命令	268





 





6.7.3 窥探内存的命令	270





 





6.7.4 针对CPU使用情况的监控命令	272





 





6.7.5 监控磁盘I/O的命令	273





 





6.7.6 查看网络信息和网络监控命令	275





 





6.7.7 Linux系统的高级工具	287





 





6.7.8 /proc文件系统	288





 





6.7.9 摘要命令	288





 





6.7.10 小结	290





 





6.8 现实中的应急和攻关案例	291





 





6.8.1 一次OOM事故的分析和定位	291





 





6.8.2 一次CPU 100%的线上事故排查	301





 





6.9 本章小结	304





 





第7章 服务的容器化过程	306





7.1 容器vs虚拟机	306





 





7.1.1 什么是虚拟机	306





 





7.1.2 什么是容器	306





 





7.1.3 容器和虚拟机的区别	307





 





7.1.4 容器主要解决的问题	307





 





7.1.5 Docker的优势	310





 





7.2 Docker实战	311





 





7.2.1 Docker的架构	311





 





7.2.2 Docker的安装	315





 





7.2.3 Docker初体验	319





 





7.2.4 Docker后台服务的管理	322





 





7.2.5 Docker的客户端命令	328





 





7.2.6 Docker Compose编排工具的使用	372





 





7.3 容器化项目	379





 





7.3.1 传统的应用部署	380





 





7.3.2 将应用程序部署在虚拟机上	380





 





7.3.3 容器化部署应用	381





 





7.3.4 Docker实现的应用容器化示例	382





 





7.4 本章小结	384





 





第8章 敏捷开发2.0的自动化工具	385





8.1 什么是敏捷开发2.0	385





 





8.1.1 常用的4种开发模式	385





 





8.1.2 什么是DevOps	390





 





8.1.3 敏捷开发2.0解决的问题	392





 





8.2 敏捷开发的自动化流程	393





 





8.2.1 持续集成	393





 





8.2.2 持续交付和持续部署	397





 





8.3 敏捷开发的常用自动化工具	400





 





8.3.1 分布式版本控制工具Git	400





 





8.3.2 持续集成和持续交付工具Jenkins	410





 





8.3.3 基础平台管理工具SaltStack	418





 





8.3.4 Docker容器化工具	421





 





8.4 本章小结	422





