---
layout: post
title: "实践Java多线程"
date: 2017-11-02 11:08:00 +0800
categories: Java
tags: java multi-thread
---



## daemon

当所有非daemon线程运行结束，这jvm会强制结束，不管此时daemon是否还在执行。

## 线程状态

![线程状态及转换](/images/threadState.png)

* New（新生）

* Runnable（可运行）：包含操作系统中的就绪和运行中

* Blocked（被阻塞）：等待获取锁（**waiting for monitor entry**）

  ```
  "RMI TCP Connection(64896)-172.16.52.118" daemon prio=10 tid=0x00000000405a6000 nid=0x68fe waiting for monitor entry [0x00007f2be65a3000]
     java.lang.Thread.State: BLOCKED (on object monitor)
  at com.xyz.goods.service.impl.GoodsServiceImpl.findChanellGoodsCountWithCache(GoodsServiceImpl.java:1734)
  - waiting to lock <0x00000000fe7e3b50> (a java.lang.String)
  ```

* Waiting（等待）：等待某个条件发生（**waiting on condition**）

  线程池等待任务
  
  ```
  "logback-3" #21 daemon prio=5 os_prio=0 tid=0x00007fcca4385000 nid=0x6453 waiting on condition [0x00007fcc98dd4000]
   java.lang.Thread.State: WAITING (parking)
	at sun.misc.Unsafe.park(Native Method)
	- parking to wait for  <0x00000000e3876f50> (a java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject)
	at java.util.concurrent.locks.LockSupport.park(LockSupport.java:175)
	at java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.await(AbstractQueuedSynchronizer.java:2039)
	at java.util.concurrent.ScheduledThreadPoolExecutor$DelayedWorkQueue.take(ScheduledThreadPoolExecutor.java:1088)
	at java.util.concurrent.ScheduledThreadPoolExecutor$DelayedWorkQueue.take(ScheduledThreadPoolExecutor.java:809)
	at java.util.concurrent.ThreadPoolExecutor.getTask(ThreadPoolExecutor.java:1074)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1134)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)
	at java.lang.Thread.run(Thread.java:748)
  ```
  
  sleep
  
  ```
  "Dubbo-Holder" #20 prio=5 os_prio=0 tid=0x00007fccc098d000 nid=0x6452 waiting on condition [0x00007fcc87efd000]
   java.lang.Thread.State: TIMED_WAITING (sleeping)
	at java.lang.Thread.sleep(Native Method)
	at io.dubbo.springboot.DubboHolderListener$1.run(DubboHolderListener.java:28)
	at java.lang.Thread.run(Thread.java:748)
  ```
  
  等待队列数据
  
  ```
  "RMI TCP Connection(idle)" daemon prio=10 tid=0x00007fd50834e800 nid=0x56b2 waiting on condition [0x00007fd4f1a59000]
     java.lang.Thread.State: TIMED_WAITING (parking)
  at sun.misc.Unsafe.park(Native Method)
  - parking to wait for  <0x00000000acd84de8> (a java.util.concurrent.SynchronousQueue$TransferStack)
  ```

  同步块中调用wait（**in Object.wait()**）

  ```
  "RMI RenewClean-[172.16.50.182:4888]" daemon prio=10 tid=0x0000000040d2c800 nid=0x97e in Object.wait() [0x00007f9ccafd0000]
     java.lang.Thread.State: TIMED_WAITING (on object monitor)
  at java.lang.Object.wait(Native Method)
  - waiting on <0x0000000799b032d8> (a java.lang.ref.ReferenceQueue$Lock)
  ```

* Timed waiting（计时等待）：跟Waiting类似，只是计时等待

* Terminated（被终止）



### Runnable

### Callable

### Future

### RunnableFuture

### FutureTask



[秒懂Java多线程](https://blog.csdn.net/ShuSheng0007/article/details/80633873)

[秒懂Java并发之volatile关键字引发的思考](https://blog.csdn.net/ShuSheng0007/article/details/84642195)
